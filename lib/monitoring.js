// Generated by CoffeeScript 1.10.0
var application, async, axon, colors, dsClient, fs, getToken, helpers, homeClient, log, makeError, path, program, proxyClient, spawn, stackApplication;

colors = require("colors");

program = require('commander');

async = require("async");

fs = require("fs");

axon = require('axon');

spawn = require('child_process').spawn;

path = require('path');

log = require('printit')();

application = require('./application');

stackApplication = require('./stack_application');

helpers = require('./helpers');

makeError = helpers.makeError;

dsClient = helpers.clients.ds;

homeClient = helpers.clients.home;

proxyClient = helpers.clients.proxy;

getToken = helpers.getToken;

module.exports.startDevRoute = function(slug, port, callback) {
  var data, doctype, err, error, error1, packageData, packagePath, perm, perms, ref, token;
  if (token = getToken()) {
    dsClient.setBasicAuth('home', token);
  }
  packagePath = process.cwd() + '/package.json';
  try {
    packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
  } catch (error1) {
    err = error1;
    error = "Run this command in the package.json directory";
    callback(makeError(err, null));
    return;
  }
  perms = {};
  ref = packageData['cozy-permissions'];
  for (doctype in ref) {
    perm = ref[doctype];
    perms[doctype.toLowerCase()] = perm;
  }
  data = {
    docType: "Application",
    state: 'installed',
    isStoppable: false,
    slug: slug,
    name: slug,
    password: slug,
    permissions: perms,
    widget: packageData['cozy-widget'],
    port: port,
    devRoute: true
  };
  return dsClient.post("data/", data, function(err, res, body) {
    if (err) {
      log.error("Create route failed");
      return callback(makeError(err, body));
    } else {
      return proxyClient.get("routes/reset", function(err, res, body) {
        if (err) {
          log.error("Reset routes failed");
          return callback(makeError(err, body));
        } else {
          log.info("Start your app with the following ENV vars:");
          log.info("NAME=" + slug + " TOKEN=" + slug + " PORT=" + port);
          log.info("Use dev-route:stop " + slug + " to remove it.");
          return callback();
        }
      });
    }
  });
};

module.exports.stopDevRoute = function(slug, callback) {
  var appsQuery, found, stopRoute, token;
  found = false;
  if (token = getToken()) {
    dsClient.setBasicAuth('home', token);
  }
  appsQuery = 'request/application/all/';
  stopRoute = function(app) {
    var isSlug;
    isSlug = app.value.slug === slug || slug === 'all';
    if (isSlug && app.value.devRoute) {
      found = true;
      return dsClient.del("data/" + app.id + "/", function(err, res, body) {
        if (err) {
          return callback(makeError(err, body));
        } else {
          log.info("Route deleted.");
          return proxyClient.get('routes/reset', function(err, res, body) {
            if (err) {
              log.error("Stop reseting proxy routes.");
              return callback(makeError(err, body));
            } else {
              return callback();
            }
          });
        }
      });
    }
  };
  return dsClient.post(appsQuery, null, function(err, res, apps) {
    if (err || (apps == null)) {
      log.error("Unable to retrieve apps data.");
      return callback(makeError(err, apps));
    } else {
      apps.forEach(stopRoute);
      if (!found) {
        return console.log("There is no dev route with this slug");
      }
    }
  });
};

module.exports.getRoutes = function(callback) {
  return proxyClient.get("routes", function(err, res, routes) {
    var route;
    if (err) {
      return callback(makeError(err, null));
    } else if (routes != null) {
      for (route in routes) {
        log.raw(route + " => " + routes[route].port);
      }
      return callback(null, routes);
    }
  });
};

module.exports.moduleStatus = function(module, callback) {
  if (module === "data-system") {
    module = 'ds';
  }
  return helpers.clients[module].get('', function(err, res) {
    var ref;
    if ((res == null) || ((ref = !res.statusCode) === 200 || ref === 401 || ref === 403)) {
      return callback("down");
    } else {
      return callback("up");
    }
  });
};

module.exports.status = function(options, callback) {
  colors.enabled = (options.raw == null) && (options.json == null);
  return async.series([stackApplication.check(options, "mta"), stackApplication.check(options, "couch"), stackApplication.check(options, "controller", "version"), stackApplication.check(options, "data-system"), stackApplication.check(options, "home"), stackApplication.check(options, "proxy", "routes")], function(err, stack) {
    var funcs, res;
    res = {};
    stack.forEach(function(app) {
      return res[app[0]] = app[1];
    });
    funcs = [];
    return application.getApps(function(err, apps) {
      var app, func, i, len, url;
      if (err != null) {
        log.error("Cannot retrieve apps");
        return callback(err);
      } else {
        for (i = 0, len = apps.length; i < len; i++) {
          app = apps[i];
          if (app.state === 'stopped') {
            if (options.json) {
              res[app.name] = "stopped";
            } else {
              log.raw((app.name + ": ") + "stopped".grey);
            }
          } else if (app.type === 'static') {
            log.raw((app.name + ": ") + "up".green + " (static)".blue);
          } else {
            url = "http://localhost:" + app.port + "/";
            func = application.check(options, app.name, url);
            funcs.push(func);
          }
        }
        return async.series(funcs, function(err, apps) {
          apps.forEach(function(app) {
            return res[app[0]] = app[1];
          });
          return callback(null, res);
        });
      }
    });
  });
};

module.exports.log = function(app, type, callback) {
  var tail;
  path = "/usr/local/var/log/cozy/" + app + ".log";
  if (!fs.existsSync(path)) {
    return callback(makeError("Log file doesn't exist (" + path + ").", null));
  } else if (type === "cat") {
    log.raw(fs.readFileSync(path, 'utf8'));
    return callback();
  } else if (type === "tail") {
    tail = spawn("tail", ["-f", path]);
    tail.stdout.setEncoding('utf8');
    tail.stdout.on('data', function(data) {
      return log.raw(data);
    });
    return tail.on('close', function(code) {
      return log.info("ps process exited with code " + code);
    });
  } else {
    return callback(makeError("<type> should be 'cat' or 'tail'", null));
  }
};
